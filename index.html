<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ê®°ÂûãÁîüÊàêÂô®</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f0f0f0; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            width: 280px;
            backdrop-filter: blur(10px);
            max-height: 90vh;
            overflow-y: auto;
        }

        h2 { margin-top: 0; color: #333; font-size: 1.2rem; text-align: center; margin-bottom: 15px; }

        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 0.9rem; }
        
        input[type="number"], select, input[type="color"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 0.9rem;
        }

        input[type="color"] { height: 40px; padding: 2px; cursor: pointer; }

        /* Buttons */
        .btn-container {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.1s, opacity 0.2s;
        }

        button:active { transform: scale(0.98); }

        #regenerate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: auto;
            padding: 12px 24px;
            box-shadow: 0 4px 10px rgba(118, 75, 162, 0.4);
            z-index: 100;
        }

        #screenshot-btn {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
            color: #555;
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: auto;
            padding: 12px 24px;
            box-shadow: 0 4px 10px rgba(255, 154, 158, 0.4);
            z-index: 100;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            #ui-container { width: calc(100% - 40px); top: 10px; left: 10px; }
            #regenerate-btn { bottom: 10px; right: 10px; }
            #screenshot-btn { bottom: 10px; left: 10px; }
        }
    </style>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-container">
        <h2>Ê®°ÂûãÂèÇÊï∞ÈÖçÁΩÆ</h2>
        
        <div class="control-group">
            <label for="length">ÈïøÂ∫¶ (Length)</label>
            <input type="number" id="length" value="10" min="5" max="50">
        </div>

        <div class="control-group">
            <label for="v-angle">Á´ñÂêëËßíÂ∫¶ (Vertical)</label>
            <select id="v-angle">
                <option value="up">‰∏äÁøò (Up)</option>
                <option value="flat" selected>Âπ≥Áõ¥ (Flat)</option>
                <option value="down">‰∏ãÂºØ (Down)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="h-angle">Ê∞¥Âπ≥ËßíÂ∫¶ (Horizontal)</label>
            <select id="h-angle">
                <option value="left">Â∑¶ÂºØ (Left)</option>
                <option value="flat" selected>Âπ≥Áõ¥ (Flat)</option>
                <option value="right">Âè≥ÂºØ (Right)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="detail">Á≤æÁªÜÂ∫¶ (Detail)</label>
            <select id="detail">
                <option value="high">Á≤æÁªÜ (High)</option>
                <option value="medium" selected>ÈÄÇ‰∏≠ (Medium)</option>
                <option value="low">Á≤óÁ≥ô (Low)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="material">ÊùêË¥® (Material)</label>
            <select id="material">
                <option value="wood">Êú®Êùê (Wood)</option>
                <option value="metal">ÈáëÂ±û (Metal)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="color">È¢úËâ≤ (Color)</label>
            <input type="color" id="color" value="#d2b48c">
        </div>
    </div>

    <button id="screenshot-btn">üì∏ ‰øùÂ≠òÊà™Âõæ</button>
    <button id="regenerate-btn">üîÑ ÈáçÊñ∞ÁîüÊàê</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let modelGroup; // Group to hold the generated parts

        // --- Initialization ---
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            scene.fog = new THREE.Fog(0xf0f0f0, 20, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 30);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true }); // preserveDrawingBuffer for screenshot
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(-10, 10, -10);
            scene.add(backLight);

            // Grid (Optional, for reference)
            const gridHelper = new THREE.GridHelper(50, 50, 0xcccccc, 0xe5e5e5);
            scene.add(gridHelper);

            // Initial Generation
            generateModel();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('regenerate-btn').addEventListener('click', generateModel);
            document.getElementById('screenshot-btn').addEventListener('click', takeScreenshot);

            // Animation Loop
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Model Generation Logic ---
        function generateModel() {
            // 1. Clear previous model
            if (modelGroup) {
                scene.remove(modelGroup);
                // Dispose geometries and materials to free memory
                modelGroup.traverse((child) => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
            modelGroup = new THREE.Group();
            scene.add(modelGroup);

            // 2. Get Inputs
            const length = parseFloat(document.getElementById('length').value) || 10;
            const vAngle = document.getElementById('v-angle').value;
            const hAngle = document.getElementById('h-angle').value;
            const detailLevel = document.getElementById('detail').value;
            const materialType = document.getElementById('material').value;
            const colorHex = document.getElementById('color').value;

            // 3. Determine Parameters
            let segments = 64;
            let radialSegments = 16;
            if (detailLevel === 'low') { segments = 32; radialSegments = 8; }
            if (detailLevel === 'high') { segments = 128; radialSegments = 32; }

            const radius = 1.5; // Base radius of the cylinder
            
            // 4. Create Material
            let material;
            if (materialType === 'wood') {
                material = new THREE.MeshStandardMaterial({
                    color: colorHex,
                    roughness: 0.8,
                    metalness: 0.1,
                });
                // Note: Real wood would need a texture, using color/roughness approximation here
            } else {
                // Metal
                material = new THREE.MeshStandardMaterial({
                    color: colorHex,
                    roughness: 0.2,
                    metalness: 0.8,
                });
            }

            // 5. Create Bent Cylinder (The Shaft)
            // We'll use a CatmullRomCurve3
            const points = [];
            const startPoint = new THREE.Vector3(0, 0, 0);
            points.push(startPoint);

            // Mid point and End point depend on angles
            // Simple logic: 
            // Flat/Flat -> Straight line up
            // Up/Down -> Bend in Z (or X)
            // Left/Right -> Bend in X (or Z)
            
            // Let's define the curve growing upwards (Y axis)
            // We add intermediate points to create the bend
            
            const midY = length * 0.5;
            const endY = length;
            
            let bendX = 0;
            let bendZ = 0;
            
            // Horizontal bend (Left/Right) - mapped to X axis
            if (hAngle === 'left') bendX = -length * 0.3;
            if (hAngle === 'right') bendX = length * 0.3;

            // Vertical bend (Up/Down) - mapped to Z axis (tilting forward/back)
            // Note: "Vertical angle" usually means pitch. 
            // "Up" -> Curving towards user? Or Upwards?
            // Since the main axis is Y (up), let's assume "Up" means curving 'back' (positive Z) and "Down" means 'forward' (negative Z) or vice versa.
            // Let's map: Up -> +Z, Down -> -Z
            if (vAngle === 'up') bendZ = -length * 0.3; // Tilt back
            if (vAngle === 'down') bendZ = length * 0.3; // Tilt forward

            const midPoint = new THREE.Vector3(bendX * 0.5, midY, bendZ * 0.5);
            const endPoint = new THREE.Vector3(bendX, endY, bendZ);

            // Add a control point for smoother curve
            points.push(midPoint);
            points.push(endPoint);

            const curve = new THREE.CatmullRomCurve3(points);
            
            const tubeGeometry = new THREE.TubeGeometry(curve, segments, radius, radialSegments, false);
            const tubeMesh = new THREE.Mesh(tubeGeometry, material);
            tubeMesh.castShadow = true;
            tubeMesh.receiveShadow = true;
            modelGroup.add(tubeMesh);

            // 6. Top Hemisphere
            // Position: At the end of the tube
            // Orientation: Tangent to the end of the curve
            const headRadius = radius * 1.05; // 5% larger
            
            // Sphere with phiLength = PI (Hemisphere)
            // We need to rotate it to align with the tube end
            const headGeo = new THREE.SphereGeometry(headRadius, radialSegments, Math.round(radialSegments/2), 0, Math.PI * 2, 0, Math.PI * 0.5);
            const headMesh = new THREE.Mesh(headGeo, material);
            
            // Position at end point
            headMesh.position.copy(endPoint);
            
            // Align rotation
            // Get tangent at t=1
            const tangent = curve.getTangent(1);
            // Default sphere points up (Y). We need to rotate Y to match tangent.
            const axis = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, tangent);
            headMesh.setRotationFromQuaternion(quaternion);
            
            modelGroup.add(headMesh);

            // "Hole" on top
            // We can add a small black circle slightly above the hemisphere surface
            const holeGeo = new THREE.CircleGeometry(headRadius * 0.2, 16);
            const holeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const holeMesh = new THREE.Mesh(holeGeo, holeMat);
            
            // Position slightly offset along the tangent so it sits on top
            const holeOffset = tangent.clone().multiplyScalar(headRadius * 1.001);
            holeMesh.position.copy(endPoint).add(holeOffset);
            
            // Rotate to face same way as head
            // Circle defaults to facing Z. Need to rotate Z to match tangent.
            const circleAxis = new THREE.Vector3(0, 0, 1);
            const circleQuat = new THREE.Quaternion().setFromUnitVectors(circleAxis, tangent);
            holeMesh.setRotationFromQuaternion(circleQuat);
            
            modelGroup.add(holeMesh);


            // 7. Bottom Spheres
            // "Two spheres at the bottom, same horizontal line, tangent to the bottom edge"
            // The tube starts at (0,0,0).
            // Let's place them at the base.
            // Tangent to the bottom edge implies they are touching the sides of the base cylinder.
            
            const baseSphereRadius = radius * 1.2; // Slightly larger than tube radius for aesthetics, or same? User said "Two identical spheres". Let's make them proportional.
            
            const sphereGeo = new THREE.SphereGeometry(baseSphereRadius, radialSegments, radialSegments);
            const sphere1 = new THREE.Mesh(sphereGeo, material);
            const sphere2 = new THREE.Mesh(sphereGeo, material);

            // Position them. 
            // Tube base is at 0,0,0.
            // They should be "below" or "at the side"?
            // "Below placed two spheres... tangent to the bottom edge"
            // Usually this shape implies a phallic or joystick shape.
            // Let's place them at x = +/- radius, y = 0 (or slightly offset).
            
            sphere1.position.set(-radius, 0, 0);
            sphere2.position.set(radius, 0, 0);
            
            sphere1.castShadow = true;
            sphere2.castShadow = true;
            
            modelGroup.add(sphere1);
            modelGroup.add(sphere2);
            
            // Center the camera on the model roughly
            controls.target.set(0, length/2, 0);
        }

        // --- Screenshot Logic ---
        function takeScreenshot() {
            // Render once to ensure fresh frame
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            
            const link = document.createElement('a');
            link.download = 'model-screenshot.png';
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Start
        init();

    </script>
</body>
</html>
